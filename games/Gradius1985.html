<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradius - Retro Edition</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- We'll use Inter as a base, but apply font-mono (Monospace) extensively for retro look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Tailwind Configuration and Custom Styles -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'black-bg': '#000000',
                        'light-gray': '#E0E0E0',
                        'medium-gray': '#AAAAAA',
                        'ship-color': '#FFFFFF',
                        'bullet-color': '#FFFFFF',
                        'enemy-color': '#FF4444', /* Using red for enemies and enemy bullets */
                        'obstacle-color': '#FFFFFF', /* CRITICAL FIX: White for static hazards (jagged rocks) */
                        'status-ok': '#E0E0E0',
                        'status-alert': '#FF4444', 
                        'status-ready': '#00FF00', // Green is allowed only for status/ready text
                    },
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                        mono: ['Roboto Mono', 'monospace'],
                    },
                },
            },
        }
    </script>

    <style>
        /*
         * MONOCHROME RETRO STYLING 
         * Replaced the neon glow with a sharp, high-contrast border and subtle inner shadow.
         */
        .mono-panel {
            box-shadow: 0 0 0 2px #E0E0E0, inset 0 0 15px rgba(255, 255, 255, 0.05);
            border-radius: 0; /* Sharp corners for retro feel */
        }

        /* Retro Button Styling */
        .mono-button {
            transition: all 0.1s ease-in-out;
            /* Initial state */
            border: 2px solid #E0E0E0;
            color: #E0E0E0;
            background-color: transparent;
            text-shadow: none;
        }

        .mono-button:hover:not(:disabled) {
            /* Hover/Selected State: Inverted colors */
            background-color: #E0E0E0;
            border-color: #000000;
            color: #000000; /* Dark text on light background */
            box-shadow: inset 0 0 5px #AAAAAA;
            transform: scale(1.01);
        }

        .mono-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(100%);
        }

        /* Typography for Data - using light gray and mono font */
        .stat-label {
            color: var(--tw-colors-medium-gray);
            font-weight: 400;
        }

        .stat-value {
            /* This is now the fallback color if no explicit Tailwind class is set */
            color: var(--tw-colors-light-gray);
            font-weight: 700;
            text-shadow: none;
        }
        
        /* Ensure the body takes up the full viewport */
        body {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--tw-colors-black-bg);
            font-family: 'Roboto Mono', monospace; /* Set global retro font */
        }

        /* Canvas container styles */
        #simulation-viewport {
            position: relative;
            background-color: #000000;
            border-radius: 0;
            flex-grow: 1;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Menu overlay styling - now only for persistent menus */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.9); 
            z-index: 10;
        }
    </style>
</head>
<body class="bg-black-bg font-mono p-4 sm:p-8">

    <!-- Main Wrapper: Handles the two-column structure and global padding -->
    <div id="main-wrapper" class="flex flex-col lg:flex-row gap-6 max-w-7xl mx-auto w-full h-full lg:h-[800px]">

        <!-- UI/HUD Panel (Left Column) -->
        <div id="ui-panel" class="mono-panel bg-black-bg p-6 lg:w-1/3 flex flex-col space-y-8 min-h-[300px] lg:min-h-full">
            
            <h1 class="text-xl font-bold text-light-gray tracking-wider uppercase text-center border-b pb-3 border-medium-gray">
                // SYSTEM STATUS: LOG
            </h1>

            <!-- Dynamic Status Display (Connected to Game) -->
            <div class="space-y-4">
                <!-- SCORE ROW: Now uses Bright Green and is much larger -->
                <div class="flex justify-between items-center border-b border-medium-gray pb-2">
                    <span class="stat-label text-base uppercase">SCORE</span>
                    <!-- CRITICAL CHANGE: Increased size and set color to text-status-ready -->
                    <span id="score-value" class="stat-value text-status-ready text-4xl font-extrabold">0</span>
                </div>
                
                <div class="flex justify-between items-center border-b border-medium-gray pb-2">
                    <span class="stat-label text-base uppercase">LEVEL</span>
                    <!-- FIX: Added explicit color classes for visibility -->
                    <span id="level-value" class="stat-value text-xl text-light-gray font-bold">1</span>
                </div>

                <div class="flex justify-between items-center border-b border-medium-gray pb-2">
                    <span class="stat-label text-base uppercase">SHIELD</span>
                    <!-- FIX: Added explicit color classes for visibility -->
                    <span id="shield-value" class="stat-value text-xl text-light-gray font-bold">100%</span>
                </div>
                
                <div class="flex justify-between items-center pb-2">
                    <span class="stat-label text-base uppercase">STATUS</span>
                    <span id="status-value" class="stat-value text-xl text-status-ready">SYSTEMS READY</span>
                </div>
            </div>

            <!-- Controls/Instructions -->
            <div class="space-y-4 pt-6 border-t border-medium-gray">
                <h2 class="text-lg font-bold text-light-gray uppercase">Controls</h2>
                <ul class="text-sm space-y-2 text-medium-gray">
                    <li><span class="text-light-gray font-bold">W/S / ↑↓</span>: Vertical Movement (Smooth Inertia)</li>
                    <li><span class="text-light-gray font-bold">A/D / ←→</span>: Horizontal Brake/Thrust</li>
                    <li><span class="text-light-gray font-bold">SPACE</span>: Fire & Start Game</li>
                    <li><span class="text-light-gray font-bold">ENTER</span>: Continue to Next Level</li>
                </ul>
            </div>
            
            <!-- Action Button -->
            <div class="mt-auto pt-6">
                <button id="start-button" class="mono-button w-full py-3 text-lg font-bold tracking-widest uppercase">
                    START / RESTART
                </button>
            </div>
            
        </div>

        <!-- Game Area (Right Column) -->
        <div id="game-wrapper" class="mono-panel bg-black-bg p-0 flex flex-col items-center justify-center relative flex-grow min-h-[500px] lg:min-h-full">
            
            <!-- Canvas for Game Drawing -->
            <div id="simulation-viewport" class="w-full h-full">
                <canvas id="gameCanvas"></canvas>
                
                <!-- Menu Overlay (Initial Screen, Paused, Game Over) -->
                <div id="menu-overlay" class="menu-overlay flex flex-col items-center justify-center text-center p-8 hidden">
                    <h2 id="menu-title" class="text-5xl font-extrabold mb-4 uppercase text-light-gray tracking-wider">
                        GRADIUS V1985.01
                    </h2>
                    <p id="menu-subtitle" class="text-xl text-status-ready mb-8">
                        PRESS SPACEBAR TO INITIATE MISSION
                    </p>
                    <p id="menu-instruction" class="text-base text-medium-gray">
                        Use W/S or Arrow Keys for control.
                    </p>
                </div>
            </div>
            
        </div>

    </div>

    <!-- Game Logic -->
    <script type="text/javascript">
        // --- GAME CONSTANTS AND CONFIGURATION ---

        // Game Environment
        const FPS = 60;
        let GAME_WIDTH = 1200; // Updated on resize
        let GAME_HEIGHT = 800; // Updated on resize
        const WORLD_SCROLL_SPEED = 2; // Base speed for enemies
        const OBSTACLE_SCROLL_SPEED = 0.5; // New, much slower speed for rocks/walls
        
        // Scaling factor (2.25) applied to all sizes for larger visuals
        const SCALE_FACTOR = 2.25;

        // Ship Constants (Size scaled by 2.25)
        const SHIP_SIZE = 24 * SCALE_FACTOR; // Triangle base (54)
        const SHIP_HEIGHT_RENDER = SHIP_SIZE * 0.75; // Actual rendered height (~40.5)
        const SHIP_THRUST = 0.5; // Acceleration force
        const SHIP_MAX_SPEED = 8;
        const SHIP_DRAG = 0.96; // Friction to slow down vertical movement
        const SHIP_INVULNERABILITY_TIME = 3 * FPS; // 3 seconds of invulnerability

        // Bullet Constants (Size scaled by 2.25)
        const BULLET_SPEED = 15;
        const BULLET_WIDTH = 8 * SCALE_FACTOR;
        const BULLET_HEIGHT = 2 * SCALE_FACTOR;
        const PLAYER_FIRE_RATE = 150; // ms

        // Enemy Constants
        // FIX: Reduced base size from 15 to 10 for better drone proportion relative to ship (54)
        const ENEMY_BASE_SIZE = 10 * SCALE_FACTOR; // 22.5
        const ENEMY_BULLET_SPEED = 6;
        const ENEMY_BULLET_RADIUS = 4;

        // Obstacle Constants
        const OBSTACLE_SIZE = 25 * SCALE_FACTOR; // Base block size (56.25)
        const TURRET_FIRE_RATE = 2 * FPS; // Turret fires every 2 seconds
        const TURRET_CHANCE_BASE = 0.15; // 15% chance for a wall piece to have a turret
        const MIN_PASSAGE_HEIGHT = SHIP_HEIGHT_RENDER * 2; // FIX: Minimum safe passage is 2x ship height

        // Scoring (High Magnitude)
        const SCORE_KILL_DRONE = 150;
        const SCORE_KILL_FIGHTER = 400;
        const SCORE_KILL_CRUISER = 750;
        const SCORE_KILL_TURRET = 1000;
        const EXTRA_LIFE_SCORE_THRESHOLD = 10000; // 10,000 points to regain shield chunk

        // Ship State Colors
        const COLOR_NORMAL = tailwind.config.theme.extend.colors['ship-color'];
        const COLOR_DAMAGED = tailwind.config.theme.extend.colors['enemy-color'];
        const COLOR_OBS = tailwind.config.theme.extend.colors['obstacle-color']; // White now

        // --- GLOBAL VARIABLES ---
        let canvas, ctx;
        let gameRunning = false;
        let gamePaused = true;
        let gameStarted = false; // Flag for first-time start
        let level = 1;
        let score = 0;
        let scoreForNextLife = EXTRA_LIFE_SCORE_THRESHOLD; // Tracks score goal for next shield chunk
        
        let ship;
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let obstacles = [];
        let explosions = [];
        let canFire = true;

        // Input state (Vertical smoothing logic)
        let input = {
            up: false, down: false, left: false, right: false, fireHeld: false, enterHeld: false
        };

        // Spawning state
        let lastEnemySpawn = 0;
        let lastObstacleSpawn = 0;
        
        // Screen Shake effect
        let screenShakeFrames = 0;
        const SHAKE_INTENSITY = 20; // Max pixel shift
        const SHAKE_DURATION_ON_HIT = 60; // 1 second shake (60 frames)
        
        // --- GAME OBJECTS (Using simple object structures for single-file simplicity) ---

        /** Represents the player's ship */
        class Ship {
            constructor() {
                this.x = SHIP_SIZE * 2; // Start near left edge
                this.y = GAME_HEIGHT / 2;
                this.vx = 0; // Horizontal velocity relative to world
                this.vy = 0; // Vertical velocity (smoothed)
                this.width = SHIP_SIZE;
                this.height = SHIP_HEIGHT_RENDER; // Use the fixed rendered height
                this.hitDelay = 0; // Invulnerability timer
                this.lives = 3; // 3 lives = 100% shield
            }
        }

        /** Represents an enemy bullet */
        class EnemyBullet {
            constructor(x, y, vx, vy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = ENEMY_BULLET_RADIUS;
            }
        }
        
        /** Generates random jagged offsets for an obstacle shape */
        function generateJaggies(numPoints) {
            const maxVariance = 0.3; // Up to 30% deviation
            const jaggies = [];
            for (let i = 0; i < numPoints; i++) {
                // Random variance between -maxVariance and +maxVariance
                jaggies.push(1 + (Math.random() * maxVariance * 2 - maxVariance));
            }
            return jaggies;
        }

        /** Represents an environmental obstacle (jagged rock) with potential turrets */
        class Obstacle {
            constructor(x, y, w, h, isWall = false) {
                this.x = x;
                this.y = y;
                this.width = w;
                this.height = h;
                this.isWall = isWall;
                this.turrets = []; // Array to hold attached turret objects
                
                // Randomly determine the number of points (8 to 15) for jagged drawing
                this.numPoints = 8 + Math.floor(Math.random() * 8); 
                this.jaggies = generateJaggies(this.numPoints);
            }
            // Simple check if two AABBs (Axis-Aligned Bounding Boxes) collide
            checkCollision(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + other.height > other.y;
            }
        }
        
        /** Represents a static turret attached to an obstacle */
        class Turret {
            constructor(x, y, parentObstacle, offsetX, offsetY) {
                this.x = x;
                this.y = y;
                this.width = 15 * SCALE_FACTOR; 
                this.height = 15 * SCALE_FACTOR;
                this.health = 2;
                this.maxHealth = 2;
                this.fireRate = TURRET_FIRE_RATE; 
                this.fireTimer = Math.floor(Math.random() * this.fireRate); // Stagger initial firing
                this.parentOffsetX = offsetX; // Offset from rock's left edge
                this.parentOffsetY = offsetY; // Offset from rock's top edge
            }
        }

        /** Represents an explosion effect */
        class Explosion {
            constructor(x, y, color = COLOR_DAMAGED) {
                this.x = x;
                this.y = y;
                this.r = 10;
                this.maxR = 60;
                this.opacity = 1.0;
                this.color = color;
            }
        }

        // --- DOM ELEMENTS ---
        const uiElements = {
            score: null, level: null, shield: null, status: null, startButton: null,
            menuOverlay: null, menuTitle: null, menuSubtitle: null, menuInstruction: null
        };

        // --- INITIALIZATION AND SETUP ---

        /** Sets up the canvas and DOM element references */
        function setupCanvas() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            const viewport = document.getElementById('simulation-viewport');
            
            function resizeCanvas() {
                // Adjust canvas size to fit the container
                canvas.width = viewport.clientWidth;
                canvas.height = viewport.clientHeight;
                // Update global reference dimensions
                GAME_WIDTH = canvas.width;
                GAME_HEIGHT = canvas.height;
                // Re-initialize ship position if needed
                if (ship && gameRunning) initShip();
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Set up DOM references
            uiElements.score = document.getElementById('score-value');
            uiElements.level = document.getElementById('level-value');
            uiElements.shield = document.getElementById('shield-value');
            uiElements.status = document.getElementById('status-value');
            uiElements.startButton = document.getElementById('start-button');
            uiElements.menuOverlay = document.getElementById('menu-overlay');
            uiElements.menuTitle = document.getElementById('menu-title');
            uiElements.menuSubtitle = document.getElementById('menu-subtitle');
            uiElements.menuInstruction = document.getElementById('menu-instruction');

            // Attach event listeners for buttons
            uiElements.startButton.addEventListener('click', handleStartAction);
        }

        /** Initializes the ship state */
        function initShip() {
            // Player ship starts on the left side
            ship = new Ship();
            ship.x = ship.width * 2; 
            ship.y = GAME_HEIGHT / 2;
        }

        /** Resets all game arrays (enemies, bullets, etc.) */
        function resetGameObjects() {
            enemies = [];
            bullets = [];
            enemyBullets = [];
            obstacles = [];
            explosions = [];
        }

        /** Resets input state to prevent stuck movement after pause/impact */
        function resetInputState() {
            input.up = input.down = input.left = input.right = false;
        }

        /** Initializes or restarts the game */
        function initGame() {
            gameStarted = true;
            gameRunning = true;
            gamePaused = false;
            level = 0; // Will be incremented in nextLevelSetup
            score = 0;
            scoreForNextLife = EXTRA_LIFE_SCORE_THRESHOLD;
            canFire = true;
            
            initShip();
            resetGameObjects();
            resetInputState();
            
            uiElements.menuOverlay.classList.add('hidden');
            setButtonState(false);
            
            updateHUD();

            // Start the main loop
            if (typeof gameLoopRef === 'undefined') {
                gameLoopRef = setInterval(gameLoop, 1000 / FPS);
            }
            
            // Start the first level
            nextLevelSetup();
        }

        /** Loads the next level, maintaining score/shield */
        function nextLevelSetup() {
            // FIX: Ensure gamePaused is explicitly set to true for the level break
            gamePaused = true; 
            level++;
            resetGameObjects();
            resetInputState();
            
            // Ensure the score threshold for the next life is updated if score is already high
            while (score >= scoreForNextLife) {
                scoreForNextLife += EXTRA_LIFE_SCORE_THRESHOLD;
            }
            
            // Show level transition screen
            uiElements.menuTitle.textContent = 'MISSION SUCCESS';
            uiElements.menuSubtitle.textContent = `LEVEL ${level - 1} CLEARED. INITIATING MISSION ${level}...`;
            uiElements.menuInstruction.textContent = 'PRESS ENTER TO CONTINUE FLIGHT';
            // FIX: Show the menu overlay
            uiElements.menuOverlay.classList.remove('hidden'); 
            
            // Re-enable all buttons now that the pause is visible
            setButtonState(false);
            
            updateHUD();
        }

        // --- GAME LOOP AND UPDATES ---

        /** The main game loop */
        function gameLoop() {
            // Apply screen shake if active
            let offsetX = 0, offsetY = 0;
            if (screenShakeFrames > 0) {
                offsetX = Math.random() * SHAKE_INTENSITY * 2 - SHAKE_INTENSITY;
                offsetY = Math.random() * SHAKE_INTENSITY * 2 - SHAKE_INTENSITY;
                screenShakeFrames--;
            }

            ctx.save();
            ctx.translate(offsetX, offsetY);
            
            drawBackground();
            
            if (gameRunning && !gamePaused) {
                // Core Game Updates
                updateShip();
                updateBullets();
                updateEnemies();
                updateObstacles();
                updateExplosions();
                
                // Collision check must happen after all position updates
                checkCollisions(); 
                
                spawnLogic();
                
                // Check for level completion (score threshold)
                // This condition is used to ensure the player has played long enough to clear the current level
                if (score >= level * 6000 && level > 0) { 
                    nextLevelSetup();
                }

            } else if (!gameRunning && gameStarted) {
                // Game Over screen is displayed, allow explosions to finish
                updateExplosions(); 
            } else {
                // Paused / Menu state: draw static objects
                drawShip(); 
                drawBullets();
                drawEnemies();
                drawObstacles();
            }
            
            updateHUD();
            ctx.restore();
        }

        /** Updates the ship's position and state */
        function updateShip() {
            if (!gameRunning) return;

            // Invulnerability blink timer
            if (ship.hitDelay > 0) {
                ship.hitDelay--;
            }

            // --- Vertical Movement Smoothing ---
            if (input.up) {
                ship.vy -= 0.5;
            } else if (input.down) {
                ship.vy += 0.5;
            } else {
                ship.vy *= 0.8; // Apply drag to vertical speed
                if (Math.abs(ship.vy) < 0.1) ship.vy = 0;
            }

            // Cap vertical speed
            const VERTICAL_SPEED = 5;
            if (ship.vy > VERTICAL_SPEED) ship.vy = VERTICAL_SPEED;
            if (ship.vy < -VERTICAL_SPEED) ship.vy = -VERTICAL_SPEED;
            
            // --- Horizontal Movement Smoothing ---
            const HORIZONTAL_ACCEL = 0.1;
            const MAX_HORIZONTAL_SPEED = 3; 

            if (input.right) {
                ship.vx += HORIZONTAL_ACCEL; 
            } else if (input.left) {
                ship.vx -= HORIZONTAL_ACCEL;
            } else {
                // Apply drag to bring relative speed back to 0
                ship.vx *= 0.9;
                if (Math.abs(ship.vx) < 0.1) ship.vx = 0;
            }
            
            // Cap horizontal velocity relative to world
            if (ship.vx > MAX_HORIZONTAL_SPEED) ship.vx = MAX_HORIZONTAL_SPEED;
            if (ship.vx < -MAX_HORIZONTAL_SPEED) ship.vx = -MAX_HORIZONTAL_SPEED;
            
            // Update position
            ship.y += ship.vy;
            ship.x += ship.vx; // Apply horizontal adjustment
            
            // Keep ship within vertical bounds
            if (ship.y < 0) ship.y = 0;
            if (ship.y > GAME_HEIGHT - ship.height) ship.y = GAME_HEIGHT - ship.height;
            
            // Keep ship within a forward window (can't go too far back or forward)
            const minX = ship.width / 2;
            const maxX = GAME_WIDTH / 2; // Ship can't go past the center of the screen
            if (ship.x < minX) ship.x = minX;
            if (ship.x > maxX) ship.x = maxX;
            
            drawShip();
        }

        /** Updates and draws player bullets */
        function updateBullets() {
            bullets = bullets.filter(b => {
                b.x += BULLET_SPEED;
                return b.x < GAME_WIDTH; // Keep bullet if within bounds
            });
            drawBullets();
        }

        /** Updates and draws enemy bullets */
        function updateEnemyBullets() {
            enemyBullets = enemyBullets.filter(b => {
                b.x += b.vx;
                b.y += b.vy;
                // Keep bullet if within bounds
                return b.x > 0 && b.x < GAME_WIDTH && b.y > 0 && b.y < GAME_HEIGHT;
            });
            drawEnemyBullets();
        }

        /** Updates and draws enemies */
        function updateEnemies() {
            enemies = enemies.filter(e => {
                // Enemies always move left due to world scroll
                e.x -= WORLD_SCROLL_SPEED;

                // Apply specific pattern movement (Simplified)
                if (e.type === 'Fighter') {
                    // Simple homing/diving
                    const targetY = ship.y + ship.height / 2;
                    e.y += (targetY - (e.y + e.height / 2)) * 0.03;
                } else if (e.type === 'Cruiser') {
                    // Slower movement
                    e.x -= WORLD_SCROLL_SPEED * 0.2;
                }
                
                return e.x + e.width > 0; // Keep enemy if on screen
            });
            drawEnemies();
            updateEnemyBullets();
        }

        /** Updates and draws obstacles (Jagged Rocks) and their Turrets */
        function updateObstacles() {
            obstacles = obstacles.filter(o => {
                // CRITICAL FIX: Obstacles scroll slower
                o.x -= OBSTACLE_SCROLL_SPEED; 

                // Turret logic update for obstacles
                o.turrets.forEach(t => {
                    // Turret position updates based on parent obstacle position
                    t.x = o.x + t.parentOffsetX;
                    t.y = o.y + t.parentOffsetY;

                    // Turret firing logic
                    if (gameRunning && !gamePaused) {
                        t.fireTimer--;
                        if (t.fireTimer <= 0) {
                            fireEnemyBullet(t);
                            t.fireTimer = TURRET_FIRE_RATE;
                        }
                    }
                });
                
                // Only keep on-screen rocks or if rock is still on screen (turrets are removed with rock)
                return o.x + o.width > 0; 
            });
            drawObstacles();
        }
        
        /** Updates explosion effects */
        function updateExplosions() {
            explosions = explosions.filter(e => {
                // Explosions also scroll (slower, like the rocks they came from)
                e.x -= OBSTACLE_SCROLL_SPEED; 
                e.r += 3;
                e.opacity -= 0.05;
                return e.opacity > 0 && e.r < e.maxR;
            });
        }

        // --- DRAWING FUNCTIONS ---

        /** Draws a black background */
        function drawBackground() {
            ctx.fillStyle = tailwind.config.theme.extend.colors['black-bg'];
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        /** Draws the player's ship */
        function drawShip() {
            if (ship.hitDelay > 0 && Math.floor(ship.hitDelay / 5) % 2 === 0) {
                // Blink effect during invulnerability
                return;
            }

            const color = (ship.lives <= 1 && ship.hitDelay > 0) ? COLOR_DAMAGED : COLOR_NORMAL;
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;

            // Draw a triangle (arrow) shape
            ctx.beginPath();
            // Ship is a right-facing triangle
            const noseX = ship.x + ship.width / 2;
            const noseY = ship.y + ship.height / 2;
            const tailTopX = ship.x - ship.width / 2;
            const tailTopY = ship.y;
            const tailBottomX = ship.x - ship.width / 2;
            const tailBottomY = ship.y + ship.height;
            
            ctx.moveTo(noseX, noseY);
            ctx.lineTo(tailTopX, tailTopY);
            ctx.lineTo(tailBottomX, tailBottomY);
            ctx.closePath();
            ctx.stroke();

            // Draw engine glow (if accelerating or decelerating)
            if (input.right || input.left) {
                ctx.fillStyle = COLOR_NORMAL;
                ctx.beginPath();
                const flameLength = ship.width * (0.3 + Math.random() * 0.2);
                
                ctx.moveTo(tailTopX, tailTopY);
                ctx.lineTo(ship.x - ship.width / 2 - flameLength, noseY);
                ctx.lineTo(tailBottomX, tailBottomY);
                ctx.fill();
            }
        }

        /** Draws player bullets */
        function drawBullets() {
            ctx.fillStyle = tailwind.config.theme.extend.colors['bullet-color'];
            bullets.forEach(b => {
                ctx.fillRect(b.x, b.y, BULLET_WIDTH, BULLET_HEIGHT);
            });
        }

        /** Draws enemy bullets */
        function drawEnemyBullets() {
            ctx.fillStyle = tailwind.config.theme.extend.colors['enemy-color'];
            enemyBullets.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        /** Draws all enemies (Non-turret enemies) */
        function drawEnemies() {
            enemies.forEach(e => {
                // Set stroke based on enemy color attribute
                ctx.strokeStyle = e.color;
                
                // Set line width: thicker if damaged
                ctx.lineWidth = e.health < e.maxHealth ? 4 : 2; 

                const halfW = e.width / 2;
                const halfH = e.height / 2;
                const centerX = e.x;
                const centerY = e.y;

                ctx.beginPath();
                
                if (e.type === 'Drone' || e.type === 'Fighter') {
                    // Draw a simple left-facing wedge/arrowhead
                    ctx.moveTo(centerX + halfW, centerY); // Nose (right)
                    ctx.lineTo(centerX - halfW, centerY - halfH); // Wing top (left)
                    ctx.lineTo(centerX - halfW, centerY + halfH); // Wing bottom (left)
                    ctx.closePath();
                    
                } else if (e.type === 'Cruiser') {
                    // Draw a large square with internal divisions
                    ctx.rect(centerX - halfW, centerY - halfH, e.width, e.height);
                    
                    // Add internal detail lines (struts)
                    ctx.moveTo(centerX, centerY - halfH);
                    ctx.lineTo(centerX, centerY + halfH); 
                    ctx.moveTo(centerX - halfW, centerY);
                    ctx.lineTo(centerX + halfW, centerY); 
                }
                
                ctx.stroke();
            });
        }

        /** Draws all obstacles (jagged rocks) and their turrets */
        function drawObstacles() {
            obstacles.forEach(o => {
                // 1. Draw Jagged Rock Outline
                ctx.strokeStyle = COLOR_OBS; // White
                ctx.lineWidth = 3;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; // Inner fill for definition
                ctx.beginPath();

                // Generate a simple, irregular shape using stored jaggies
                const numPoints = o.jaggies.length; 
                const centerX = o.x + o.width / 2;
                const centerY = o.y + o.height / 2;
                const baseRadiusX = o.width / 2;
                const baseRadiusY = o.height / 2;
                
                for (let i = 0; i < numPoints; i++) {
                    const angle = i * (Math.PI * 2 / numPoints);
                    // Use stored jaggies for random variance
                    const variance = o.jaggies[i]; 

                    // Calculate point position, constrained by object bounds
                    let px = centerX + baseRadiusX * variance * Math.cos(angle);
                    let py = centerY + baseRadiusY * variance * Math.sin(angle);
                    
                    // Clamp points to stay within the general AABB of the obstacle
                    px = Math.max(o.x, Math.min(o.x + o.width, px));
                    py = Math.max(o.y, Math.min(o.y + o.height, py));
                    
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.closePath();
                ctx.stroke();

                // 2. Draw Attached Turrets
                o.turrets.forEach(t => {
                    if (t.health <= 0) return; // Turret is destroyed

                    // Draw Turret Base (Square)
                    ctx.fillStyle = COLOR_DAMAGED; // Red for turret body
                    ctx.fillRect(t.x - t.width / 2, t.y - t.height / 2, t.width, t.height);

                    // Draw thicker border if damaged
                    ctx.strokeStyle = COLOR_DAMAGED;
                    ctx.lineWidth = t.health < t.maxHealth ? 4 : 2;
                    ctx.strokeRect(t.x - t.width / 2, t.y - t.height / 2, t.width, t.height);

                    // Draw barrel pointing left
                    ctx.beginPath();
                    ctx.moveTo(t.x - t.width / 2, t.y);
                    ctx.lineTo(t.x - t.width * 1.5, t.y);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            });
        }

        /** Draws explosion effects */
        function drawExplosions() {
            explosions.forEach(e => {
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 68, 68, ${e.opacity})`;
                ctx.lineWidth = 4;
                ctx.stroke();
            });
        }
        
        // --- GAME LOGIC AND HELPER FUNCTIONS ---

        /** Sets the disabled state of all interactive buttons */
        function setButtonState(disabled) {
            uiElements.startButton.disabled = disabled;
        }

        /** Handles game over sequence */
        function gameOver() {
            gameRunning = false;
            gamePaused = true;
            
            uiElements.menuTitle.textContent = 'MISSION FAILED';
            uiElements.menuSubtitle.textContent = `FINAL SCORE: ${score.toLocaleString()}`;
            uiElements.menuInstruction.textContent = 'PRESS SPACEBAR TO RESTART';
            uiElements.menuOverlay.classList.remove('hidden');
            
            setButtonState(true);
            updateHUD();
        }
        
        /** Called when the ship is hit by an enemy, obstacle, or bullet */
        function shipHit() {
            if (ship.hitDelay > 0) return; // Already invulnerable

            ship.lives--;
            screenShakeFrames = SHAKE_DURATION_ON_HIT; // Start intense screen shake
            ship.hitDelay = SHIP_INVULNERABILITY_TIME; // 3 seconds of invulnerability
            
            // Clear ship velocity but keep position
            ship.vx = 0;
            ship.vy = 0;

            // Disable buttons for the duration of the invulnerability
            setButtonState(true); 
            setTimeout(() => {
                 if (!gameOver) setButtonState(false);
            }, SHIP_INVULNERABILITY_TIME * 1000 / FPS);

            // Create explosion effect at ship location
            explosions.push(new Explosion(ship.x, ship.y));

            if (ship.lives <= 0) {
                gameOver();
            }
        }

        /** Checks for all collisions */
        function checkCollisions() {
            const shipBox = {
                x: ship.x - ship.width / 2, y: ship.y, 
                width: ship.width, height: ship.height
            };

            // 1. Player Bullet vs. Enemies/Turrets
            bullets = bullets.filter(b => {
                let hit = false;
                const bulletBox = {x: b.x, y: b.y, width: BULLET_WIDTH, height: BULLET_HEIGHT};
                
                // Check against regular enemies
                enemies = enemies.filter(e => {
                    const enemyBox = {
                        x: e.x - e.width / 2, y: e.y - e.height / 2, 
                        width: e.width, height: e.height
                    };
                    if (isColliding(bulletBox, enemyBox)) {
                        hit = true;
                        e.health--;
                        if (e.health <= 0) {
                            handleEnemyDeath(e);
                            return false; // Remove enemy
                        }
                        return true; // Keep enemy
                    }
                    return true;
                });
                
                // Check against turrets attached to obstacles
                obstacles.forEach(o => {
                    o.turrets = o.turrets.filter(t => {
                        const turretBox = {
                            x: t.x - t.width / 2, y: t.y - t.height / 2, 
                            width: t.width, height: t.height
                        };
                        if (isColliding(bulletBox, turretBox)) {
                            hit = true;
                            t.health--;
                            if (t.health <= 0) {
                                handleTurretDeath(t);
                                return false; // Remove turret
                            }
                            return true; // Keep turret
                        }
                        return true;
                    });
                });

                return !hit; // Keep bullet if it didn't hit anything
            });

            // 2. Ship vs. Enemies/Obstacles/Enemy Bullets (Only if not invulnerable)
            if (ship.hitDelay === 0) {
                // Ship vs. Regular Enemies
                enemies.forEach(e => {
                    const enemyBox = {
                        x: e.x - e.width / 2, y: e.y - e.height / 2, 
                        width: e.width, height: e.height
                    };
                    if (isColliding(shipBox, enemyBox)) {
                        shipHit();
                    }
                });

                // Ship vs. Enemy Bullets
                enemyBullets = enemyBullets.filter(b => {
                    const bulletBox = {x: b.x - b.radius, y: b.y - b.radius, width: b.radius * 2, height: b.radius * 2};
                    if (isColliding(shipBox, bulletBox)) {
                        shipHit();
                        return false; // Remove enemy bullet
                    }
                    return true;
                });

                // Ship vs. Obstacles (Jagged Rocks) and Turrets
                obstacles.forEach(o => {
                    // Check turrets first
                    o.turrets.forEach(t => {
                        const turretBox = {x: t.x - t.width / 2, y: t.y - t.height / 2, width: t.width, height: t.height};
                        if (isColliding(shipBox, turretBox)) {
                             shipHit();
                        }
                    });
                    
                    // Check rock body collision
                    if (o.checkCollision(shipBox)) {
                        shipHit(); // Hit the Rock body
                    }
                });
            }
        }
        
        /** Checks for AABB collision */
        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        /** Handles what happens when an enemy is destroyed */
        function handleEnemyDeath(e) {
            let points = SCORE_KILL_DRONE;
            if (e.type === 'Fighter') points = SCORE_KILL_FIGHTER;
            if (e.type === 'Cruiser') points = SCORE_KILL_CRUISER;

            scorePoints(points, e.x, e.y);
            explosions.push(new Explosion(e.x, e.y));
        }

        /** Handles what happens when a turret is destroyed */
        function handleTurretDeath(t) {
            scorePoints(SCORE_KILL_TURRET, t.x, t.y);
            explosions.push(new Explosion(t.x, t.y));
        }

        /** Adds points and checks for shield recovery */
        function scorePoints(amount, x, y) {
            score += amount;
            
            // Check for shield recovery (33% shield restore)
            if (ship.lives < 3 && score >= scoreForNextLife) {
                ship.lives = Math.min(3, ship.lives + 1);
                scoreForNextLife += EXTRA_LIFE_SCORE_THRESHOLD; // Advance threshold
                
                // Add a special explosion effect for recovery
                explosions.push(new Explosion(x, y, COLOR_OBS));
            } else if (score >= scoreForNextLife) {
                // If already max life, just advance the threshold
                 scoreForNextLife += EXTRA_LIFE_SCORE_THRESHOLD;
            }
        }

        /** Spawns a new player bullet */
        function fireBullet() {
            if (canFire) {
                // Player fires from the nose of the ship
                const bulletX = ship.x + ship.width / 2;
                const bulletY = ship.y + ship.height / 2 - BULLET_HEIGHT / 2;
                
                bullets.push({ 
                    x: bulletX, y: bulletY, 
                    width: BULLET_WIDTH, height: BULLET_HEIGHT,
                    hit: false,
                });
                canFire = false;
                setTimeout(() => canFire = true, PLAYER_FIRE_RATE);
            }
        }

        /** Spawns a bullet from an enemy/turret */
        function fireEnemyBullet(source) {
            const angle = Math.atan2(
                (ship.y + ship.height / 2) - source.y, 
                (ship.x + ship.width / 2) - source.x
            );

            // Simple projectile motion towards the player
            const vx = ENEMY_BULLET_SPEED * Math.cos(angle);
            const vy = ENEMY_BULLET_SPEED * Math.sin(angle);
            
            enemyBullets.push(new EnemyBullet(source.x, source.y, vx, vy));
        }

        // --- SPAWNING LOGIC ---
        
        function spawnLogic() {
            const time = Date.now();
            
            // Base time between spawns, scaled by level for difficulty
            const baseSpawnRate = 1200; // 1.2 seconds base
            
            // FIX: Difficulty scaling adjusted for a much slower start (level - 1)
            const activeLevel = Math.max(1, level);
            const enemyLevelMultiplier = (activeLevel - 1) * 0.2;
            const enemySpawnInterval = baseSpawnRate / (1 + enemyLevelMultiplier);
            
            // FIX: Obstacles start much sparser (base * 5)
            const obstacleBaseRate = baseSpawnRate * 5; // 6 seconds base spawn
            const obstacleLevelMultiplier = (activeLevel - 1) * 0.1;
            const obstacleSpawnInterval = obstacleBaseRate / (1 + obstacleLevelMultiplier); 
            
            // 1. Enemy Spawning
            if (time - lastEnemySpawn > enemySpawnInterval) {
                spawnEnemyGroup();
                lastEnemySpawn = time;
            }

            // 2. Obstacle Spawning (Jagged Rocks & Turrets)
            if (time - lastObstacleSpawn > obstacleSpawnInterval) {
                spawnObstacleGroup();
                lastObstacleSpawn = time;
            }
        }

        /** Spawns enemies based on a weighted chance */
        function spawnEnemyGroup() {
            const random = Math.random();
            let type = 'Drone';
            let health = 1;

            if (random < 0.10) { // 10% chance for a Formation
                spawnFormation();
                return;
            } else if (random < 0.30) { // 20% chance for a Cruiser
                type = 'Cruiser';
                health = 3;
            } else if (random < 0.55) { // 25% chance for a Fighter
                type = 'Fighter';
                health = 2;
            } 
            // Default is Drone (45% chance)
            
            const startY = Math.random() * (GAME_HEIGHT - ENEMY_BASE_SIZE) + ENEMY_BASE_SIZE / 2;
            spawnEnemy(type, startY, health);
        }

        /** Spawns a tight V formation of drones */
        function spawnFormation() {
            const startY = Math.random() * (GAME_HEIGHT - 100) + 50;
            const separation = 40;
            // Use basic drone stats for formation
            spawnEnemy('Drone', startY, 1);
            spawnEnemy('Drone', startY - separation, 1);
            spawnEnemy('Drone', startY + separation, 1);
        }
        
        /** Creates and adds an individual enemy */
        function spawnEnemy(type, y, health) {
            let size = ENEMY_BASE_SIZE;
            let height = ENEMY_BASE_SIZE;

            if (type === 'Cruiser') {
                size = 30 * SCALE_FACTOR;
                height = size; // Cruisers are squares
            } else if (type === 'Drone' || type === 'Fighter') {
                // FIX: Match height to the ship's actual rendered height
                size = ENEMY_BASE_SIZE;
                height = SHIP_HEIGHT_RENDER; 
            }
            
            const enemy = {
                x: GAME_WIDTH + size, // Off screen right
                y: y,
                width: size, 
                height: height, 
                vx: 0, vy: 0, 
                type: type,
                health: health,
                maxHealth: health,
                color: (type === 'Cruiser') ? COLOR_NORMAL : COLOR_DAMAGED
            };
            enemies.push(enemy);
        }

        /** Spawns jagged rock obstacles, sometimes with turrets */
        function spawnObstacleGroup() {
            const turretsChance = TURRET_CHANCE_BASE + (level * 0.05); // Turret frequency increases with level
            const random = Math.random();

            if (random < 0.4) { // 40% chance for a single, blocky rock
                // Single large rock (original style, but now with slow movement and jagged edges)
                const w = OBSTACLE_SIZE;
                const h = OBSTACLE_SIZE;
                const y = Math.random() * (GAME_HEIGHT - h);
                const obs = new Obstacle(GAME_WIDTH, y, w, h);
                obstacles.push(obs);

                if (Math.random() < turretsChance) {
                    // Attach a turret to the left side of the rock
                    const turret = new Turret(0, 0, obs, obs.width * 0.5, obs.height * 0.5);
                    obs.turrets.push(turret);
                }

            } else { 
                // 60% chance for Cave/Wall Structure (Long and Wide)
                
                // FIX: Ensure minimum gap is large enough for the ship
                const maxGapHeight = GAME_HEIGHT - MIN_PASSAGE_HEIGHT; 
                const levelDifficultyFactor = 1 + level * 0.05;
                
                let gapHeight = MIN_PASSAGE_HEIGHT + (maxGapHeight / levelDifficultyFactor); // Gap gets tighter as level increases
                gapHeight = Math.max(MIN_PASSAGE_HEIGHT, gapHeight); // Never smaller than MIN_PASSAGE_HEIGHT
                
                // Calculate max Y position for the gap center
                const maxGapY = GAME_HEIGHT - gapHeight;
                const gapY = Math.random() * maxGapY; // Random starting point for the gap
                
                const wallW = 200 * SCALE_FACTOR; // Much wider blocks for cave feel

                // Top Wall (Ceiling)
                const topWall = new Obstacle(GAME_WIDTH, 0, wallW, gapY, true);
                obstacles.push(topWall);

                // Bottom Wall (Floor)
                const bottomWall = new Obstacle(GAME_WIDTH, gapY + gapHeight, wallW, GAME_HEIGHT - (gapY + gapHeight), true);
                obstacles.push(bottomWall);
                
                // Add Turret to the top wall (pointed down at the gap)
                if (Math.random() < turretsChance) {
                    const topTurret = new Turret(0, 0, topWall, topWall.width / 2, topWall.height);
                    topWall.turrets.push(topTurret);
                }

                 // Add Turret to the bottom wall (pointed up at the gap)
                if (Math.random() < turretsChance) {
                    const bottomTurret = new Turret(0, 0, bottomWall, bottomWall.width / 2, 0);
                    bottomWall.turrets.push(bottomTurret);
                }
            }
        }

        // --- HUD UPDATES ---

        /** Updates the information displayed in the left HUD panel */
        function updateHUD() {
            // Score
            uiElements.score.textContent = score.toLocaleString();

            // Level
            const shieldPercent = Math.max(0, ship.lives * 33);
            uiElements.level.textContent = level;
            uiElements.shield.textContent = `${shieldPercent}%`;
            
            // Status/Game State
            let statusText = 'SYSTEMS READY';
            let statusColor = 'text-status-ready';
            
            if (gameRunning) {
                if (ship.hitDelay > 0) {
                     statusText = 'IMPACT: SHIELD RECALIBRATING';
                     statusColor = 'text-status-alert';
                } else {
                     statusText = 'MISSION ACTIVE';
                     statusColor = 'text-status-ok';
                }
            } else if (gameStarted) {
                if (ship.lives <= 0) {
                    statusText = 'TERMINATED';
                    statusColor = 'text-status-alert';
                } else if (gamePaused) {
                    statusText = 'HOLD';
                    statusColor = 'text-status-ok'; // Hold is not an error
                }
            } 
            
            uiElements.status.textContent = statusText;
            uiElements.status.className = `stat-value text-xl ${statusColor}`;
            
            // Button Text and State
            if (gameRunning && !gamePaused) {
                uiElements.startButton.textContent = 'PAUSE [P]';
            } else if (gamePaused && gameStarted) {
                if (ship.lives <= 0) {
                     uiElements.startButton.textContent = 'RESTART [SPACE]';
                } else if (level > 0 && enemies.length === 0 && obstacles.length === 0) {
                     uiElements.startButton.textContent = 'NEXT MISSION [ENTER]';
                } else {
                     uiElements.startButton.textContent = 'RESUME [SPACE]';
                }
            } else {
                 uiElements.startButton.textContent = 'START / RESTART';
            }
        }

        // --- MENU LOGIC ---
        function drawMenu(title, message, instruction) {
            uiElements.menuTitle.textContent = title;
            uiElements.menuSubtitle.textContent = message;
            uiElements.menuInstruction.textContent = instruction;
            uiElements.menuOverlay.classList.remove('hidden');
        }

        function togglePause() {
            if (gameRunning && !gamePaused) {
                gamePaused = true;
                drawMenu('SYSTEM PAUSED', 'ACTION SUSPENDED', 'PRESS P OR BUTTON TO RESUME FLIGHT');
            } else if (gamePaused) {
                gamePaused = false;
                uiElements.menuOverlay.classList.add('hidden');
                ship.hitDelay = 0; // Clear invulnerability if resuming manually
            }
            updateHUD();
        }

        // --- EVENT HANDLERS ---
        
        /** Handles button click actions */
        function handleStartAction() {
            if (!gameStarted || ship.lives <= 0) {
                initGame(); // START / RESTART
            } else if (gamePaused) {
                if (enemies.length === 0 && obstacles.length === 0) {
                    // Continuing from Level Complete Screen
                    gamePaused = false;
                    uiElements.menuOverlay.classList.add('hidden');
                } else {
                    // RESUME from manual PAUSE
                    togglePause();
                }
            } else {
                // PAUSE
                togglePause();
            }
        }

        /** Handles keyboard key downs */
        function keyDownHandler(e) {
            // General Controls
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') input.up = true;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') input.down = true;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') input.left = true;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') input.right = true;
            
            if (e.key === 'p' || e.key === 'P') togglePause();
            
            // Fire / Start / Resume (SPACEBAR)
            if (e.key === ' ') {
                e.preventDefault(); 
                
                if (!gameRunning || ship.lives <= 0) {
                    initGame();
                } else if (gamePaused) {
                    // Resume from manual pause
                    togglePause();
                } else {
                    fireBullet();
                }
            }

            // Next Level (ENTER)
             if (e.key === 'Enter') {
                e.preventDefault();
                // Check if we are on the Mission Success screen (paused and cleared objects)
                if (gamePaused && enemies.length === 0 && obstacles.length === 0) {
                    gamePaused = false;
                    uiElements.menuOverlay.classList.add('hidden');
                }
            }
        }

        /** Handles keyboard key ups */
        function keyUpHandler(e) {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') input.up = false;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') input.down = false;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') input.left = false;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') input.right = false;
        }
        
        // --- START GAME ---

        let gameLoopRef;

        window.onload = function () {
            setupCanvas();
            
            // Set initial state before game loop starts
            initShip();
            resetGameObjects();
            updateHUD();
            
            // Ensure the main menu is visible on load
            drawMenu('GRADIUS V1985.01', 'PRESS SPACEBAR TO INITIATE MISSION', 'Use W/S or Arrow Keys for control.');
            setButtonState(false); // Enable button for initial start

            // Start the main loop (runs constantly, updates only happen when gameRunning is true)
            gameLoopRef = setInterval(gameLoop, 1000 / FPS);

            // Add input listeners
            document.addEventListener('keydown', keyDownHandler);
            document.addEventListener('keyup', keyUpHandler);
        };
    </script>
</body>
</html>
