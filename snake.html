<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Snake - Owen & Caleb</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #0d0d0d;
            font-family: 'Press Start 2P', monospace; /* Use the new font */
            color: #fff;
        }
        
        #ui-bar {
            width: 600px; /* Same width as the canvas */
            height: 60px;
            background-color: #1a1a1a;
            border-bottom: 3px solid #00ffcc; 
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.4);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            font-size: 1.2em; /* Adjusted font size for Press Start 2P */
            color: #00ffcc;
            text-shadow: 0 0 5px #00ffcc;
            margin-bottom: 2px;
        }
        
        #ui-bar span {
            font-weight: bold;
            margin-left: 5px;
        }

        canvas {
            border: 4px solid #1f1f1f;
            box-shadow: 0 0 20px #2e2e2e;
            display: block;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    
    <div id="ui-bar" class="hidden">
        <div>PLAYER: <span id="current-player"></span></div>
        <div>SCORE: <span id="current-score">0</span></div>
    </div>

    <div id="game-container"></div>

    <script>
        // --- Game Setup and Constants ---
        let gameMode = 'MENU'; 
        let selectedPlayer = null;
        let selectedMenuIndex = 0; 
        let menuOptions = ['Owen (Blue)', 'Caleb (Orange)']; // Full text for button sizing
        
        let snake;
        let food;
        let score = 0;
        let gridSize = 20;
        let canvasSize = 600;
        let moveSpeed = 4;
        
        // Colors
        let playerColors = {
            'Owen (Blue)': { color: 'rgb(0, 191, 255)', glow: 'rgba(0, 191, 255, 0.7)', name: 'OWEN' }, // Neon Blue
            'Caleb (Orange)': { color: 'rgb(255, 165, 0)', glow: 'rgba(255, 165, 0, 0.7)', name: 'CALEB' }  // Neon Orange
        };
        const foodColor = 'rgb(255, 0, 150)';
        const menuTitleColor = 'rgb(0, 255, 204)';
        const gameOverColor = 'rgb(255, 60, 60)';
        
        const uiBar = document.getElementById('ui-bar');
        const currentPlayerSpan = document.getElementById('current-player');
        const currentScoreSpan = document.getElementById('current-score');


        // --- P5.js Setup ---
        function setup() {
            let canvas = createCanvas(canvasSize, canvasSize);
            canvas.parent('game-container');
            frameRate(60); 
            noStroke();
            textAlign(CENTER, CENTER);
            textFont('Press Start 2P'); // Set the new font
        }

        function draw() {
            background(13, 13, 13);
            
            if (gameMode === 'MENU') {
                drawMenu();
                uiBar.classList.add('hidden');
            } else if (gameMode === 'PLAYING') {
                gameLoop();
                uiBar.classList.remove('hidden');
            } else if (gameMode === 'GAMEOVER') {
                drawGameOver();
                uiBar.classList.add('hidden');
            }
            
            // Update UI Bar: Use the short name for the bar
            currentPlayerSpan.innerText = selectedPlayer ? playerColors[selectedPlayer].name : 'N/A';
            currentScoreSpan.innerText = score;
        }

        // --- Initialization and Game Logic ---

        function initGame(playerKey) {
            score = 0;
            selectedPlayer = playerKey;
            snake = new Snake(playerColors[playerKey].color);
            pickLocation();
            gameMode = 'PLAYING';
        }

        function gameLoop() {
            snake.update();
            snake.show();
            drawFood();
            
            if (snake.eats(food)) {
                score++;
                pickLocation();
            }
            
            if (snake.checkDeath()) {
                gameMode = 'GAMEOVER';
            }
        }

        function drawFood() {
            drawingContext.shadowBlur = 15;
            drawingContext.shadowColor = foodColor;
            
            fill(foodColor);
            ellipse(food.x + gridSize / 2, food.y + gridSize / 2, gridSize * 0.8, gridSize * 0.8);
            
            drawingContext.shadowBlur = 0;
        }
        
        function pickLocation() {
            let cols = floor(width / gridSize);
            let rows = floor(height / gridSize);
            let x, y;
            let maxAttempts = 100;

            do {
                x = floor(random(cols)) * gridSize;
                y = floor(random(rows)) * gridSize;
                food = createVector(x, y);
                maxAttempts--;

                let collision = false;
                if (snake) {
                    for (let i = 0; i < snake.body.length; i++) {
                        if (food.x === snake.body[i].x && food.y === snake.body[i].y) {
                            collision = true;
                            break;
                        }
                    }
                }
                if (!collision) return;

            } while (maxAttempts > 0);
        }

        // --- MENU DRAWING ---
        function drawMenu() {
            // Draw Title
            textSize(40); // Adjusted size for Press Start 2P
            fill(menuTitleColor);
            drawingContext.shadowBlur = 40;
            drawingContext.shadowColor = menuTitleColor;
            text("NEON SNAKE", width / 2, height / 4);
            drawingContext.shadowBlur = 0;

            // Draw Options
            textSize(18); // Adjusted size for content
            let startY = height / 2;
            let optionHeight = 60;
            const padding = 30; // Extra padding around the text

            menuOptions.forEach((player, index) => {
                let y = startY + index * optionHeight;
                let color = playerColors[player].color;
                let glow = playerColors[player].glow;
                
                // --- Dynamic Button Sizing ---
                // Calculate text width to determine button size
                let textW = textWidth(player); 
                let w = textW + padding; // Button width is text width + padding
                let h = 30; // Fixed height
                let x = width / 2 - w / 2; // Center the button

                // Highlight Effect for Selected Item
                if (index === selectedMenuIndex) {
                    drawingContext.shadowBlur = 30;
                    drawingContext.shadowColor = glow;
                    
                    fill(color);
                    rect(x, y, w, h, 8); // Background block for selection
                    drawingContext.shadowBlur = 0;
                    
                    fill(255); // White text on selection
                } else {
                    fill(color);
                    drawingContext.shadowBlur = 5;
                    drawingContext.shadowColor = color;
                }
                
                // Draw the text
                text(player, width / 2, y + h / 2);
                drawingContext.shadowBlur = 0;
            });

            // Instructions
            textSize(10);
            fill(150);
            text("ARROWS | ENTER", width / 2, height * 0.85);
        }

        function drawGameOver() {
            textSize(40);
            fill(gameOverColor);
            drawingContext.shadowBlur = 40;
            drawingContext.shadowColor = gameOverColor;
            text("GAME OVER", width / 2, height / 2 - 50);
            
            drawingContext.shadowBlur = 0;
            fill(255);
            textSize(20);
            text(`FINAL SCORE: ${score}`, width / 2, height / 2 + 20);
            
            textSize(12);
            text("PRESS ENTER FOR MENU", width / 2, height / 2 + 80);
        }

        // --- User Input and Events ---

        function keyPressed() {
            if (gameMode === 'PLAYING') {
                snake.setDir(keyCode);
            } else if (gameMode === 'MENU') {
                if (keyCode === UP_ARROW) {
                    selectedMenuIndex = (selectedMenuIndex - 1 + menuOptions.length) % menuOptions.length;
                } else if (keyCode === DOWN_ARROW) {
                    selectedMenuIndex = (selectedMenuIndex + 1) % menuOptions.length;
                } else if (keyCode === ENTER) {
                    initGame(menuOptions[selectedMenuIndex]);
                }
            } else if (gameMode === 'GAMEOVER') {
                if (keyCode === ENTER) {
                    gameMode = 'MENU';
                    selectedPlayer = null;
                    selectedMenuIndex = 0;
                }
            }
        }
        
        // --- Snake Class (Core logic remains the same for smooth movement) ---
        class Snake {
            constructor(color) {
                this.len = 3; 
                this.body = [];
                for(let i = 0; i < this.len * (gridSize / moveSpeed); i++) {
                     this.body.push(createVector(10 * gridSize - i * moveSpeed, 10 * gridSize));
                }
                this.vel = createVector(moveSpeed, 0); 
                this.targetDir = createVector(1, 0); 
                this.color = color;
                this.glow = playerColors[selectedPlayer].glow;
            }

            setDir(k) {
                let newTarget;
                if (k === LEFT_ARROW) newTarget = createVector(-1, 0);
                else if (k === RIGHT_ARROW) newTarget = createVector(1, 0);
                else if (k === UP_ARROW) newTarget = createVector(0, -1);
                else if (k === DOWN_ARROW) newTarget = createVector(0, 1);
                else return;

                if (newTarget.x !== -this.targetDir.x || newTarget.y !== -this.targetDir.y) {
                    this.targetDir = newTarget;
                }
            }

            eats(pos) {
                let head = this.body[0];
                let d = dist(head.x + gridSize / 2, head.y + gridSize / 2, pos.x + gridSize / 2, pos.y + gridSize / 2);

                if (d < gridSize * 0.8) { 
                    this.grow();
                    return true;
                }
                return false;
            }

            grow() {
                this.len++;
            }

            update() {
                let head = this.body[0];
                let currentGridX = floor(head.x / gridSize);
                let currentGridY = floor(head.y / gridSize);
                
                let headCenter = createVector(head.x + gridSize / 2, head.y + gridSize / 2);
                
                let isAligned = abs(headCenter.x - (currentGridX * gridSize + gridSize / 2)) < moveSpeed / 2 &&
                                abs(headCenter.y - (currentGridY * gridSize + gridSize / 2)) < moveSpeed / 2;

                if (isAligned && (this.targetDir.x !== this.vel.x / moveSpeed || this.targetDir.y !== this.vel.y / moveSpeed)) {
                    
                    head.x = currentGridX * gridSize;
                    head.y = currentGridY * gridSize;
                    
                    this.vel.x = this.targetDir.x * moveSpeed;
                    this.vel.y = this.targetDir.y * moveSpeed;
                }

                head.add(this.vel);
                this.body.unshift(head.copy()); 
                
                if (this.body.length > this.len * (gridSize / moveSpeed) + 1) { 
                    this.body.pop();
                }
            }

            checkDeath() {
                let head = this.body[0];
                let headX = head.x;
                let headY = head.y;

                if (headX < 0 || headX >= width - gridSize || headY < 0 || headY >= height - gridSize) {
                    return true;
                }

                for (let i = 50; i < this.body.length; i += 5) {
                    let segment = this.body[i];
                    let d = dist(headX, headY, segment.x, segment.y);
                    if (d < gridSize * 0.5) {
                        return true;
                    }
                }
                return false;
            }

            show() {
                drawingContext.shadowBlur = 30;
                drawingContext.shadowColor = this.glow;
                
                for (let i = 0; i < this.body.length; i += 2) { 
                    let segment = this.body[i];
                    let size = gridSize * 0.8; 
                    
                    let alpha = map(i, 0, this.body.length, 255, 50);
                    fill(red(this.color), green(this.color), blue(this.color), alpha);
                    
                    ellipse(segment.x + gridSize / 2, segment.y + gridSize / 2, size, size);
                }
                
                drawingContext.shadowBlur = 0;
            }
        }
    </script>
</body>
</html>